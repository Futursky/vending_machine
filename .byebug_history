expect { described_class.msg(:select_product).inspect }.to output(msg.inspect).to_stdout
output(msg.inspect).to_stderr
output(msg.inspect)
described_class.msg(:select_product)
msg.inspect
described_class.msg(:select_product).string
described_class.msg(:select_product).to_s
described_class.msg(:select_product).inspect
c
exit
subject.show_coins_list.inspect == msg.inspect
subject.show_coins_list.to_s
subject.show_coins_list
msg.inspect
msg
exit
subject.show_coins_list.inspect
subject.show_coins_list.
subject.show_coins_list
msg.inspect
c
expect { subject.show_coins_list.inspect }.to output(msg.inspect).to_stdout
expect { subject.show_coins_list.to_s }.to output(msg).to_stdout
expect { subject.show_coins_list }.to output(msg).to_stdout
subject.show_coins_list
{ subject.show_coins_list }.to output
subject.show_coins_list
subject.show_coins_list.to_s
output(msg).to_stdout
subject.show_coins_list
c
exit
subject.run.inspect
output(msg).expected
output(msg).inspect
msg.inspect
exit
2
subject.run.to_s
msg
output(msg)
exit
subject.run.inspect
c
exit
subject.run.inspect
c
exit
subject.run
subject
exit
subject.show_coins_list
c
coin
exit
STDIN.gets.chomp
coin.empty?
coin
c
exit
c
exit
c
payment
c
payment.join(', ')
payment
c
payment
enough_coins_to_buy?(selected_product)
payment
exit
payment
payment.join(', ')
reason
exit
c
supported_nominals.include?(coin)
coin
c
coin
c
exit
enough_coins_for_change?(selected_product)
enough_coins_to_buy?(selected_product)
exit
total
product_price
c
enough_coins_to_buy?(selected_product)
exit
enough_coins_to_buy?(selected_product)
exit
payment
c
payment
 @payment
c
payment
c
payment
c
payment
c
payment
c
payment
coin
c
coin_available?(coin)
coin
payment
c
exit
payment
c
payment
c
payment
c
payment
payment.include?(coin)
c
payment.include?(coin)
c
payment.include?(coin)
coin
exit
c
payment
c
payment
exit
Coin.payment
self.is
self
exit
c
payment
c
payment
exit
payment
c
payment
c
payment
exit
coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
payment
coin
payment.include?(coin)
coin
payment.include?(coin)
c
payment.include?(coin)
c
payment.include?(coin)
coin
c
payment.include?(coin)
coin
exit
change_valid?(change_sum, change)
change
exit
payment.index(nil)
payment.index(0)
payment
payment.slice!(payment.index(1)) if payment.index(1)
payment.slice!(payment.index(6)) if payment.index(1)
payment.slice!(payment.index(6)) if payment.index(6)
payment.index(6)
payment.slice!(payment.index(6))
payment.slice!(payment.index(1))
payment.slice!(payment.index(0))
payment
payment.slice!(payment.index(5))
payment
payment.slice!(payment.index(1))
payment = slice!(payment.index(1))
payment = slice!(a.index(1))
payment ||= coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
payment = nil
payment ||= coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
coins
payment ||= coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
payment - [5]
payment - 5
payment
payment.delete(1)
payment.remove(1)
payment
payment ||= coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
coins.flat_map { |coin| [coin[:value]] * coin[:quantity] }
coins.flat_map { |coin| [coin[:quantity]] * coin[:value] }
coins.flat_map { |coin| coin[:quantity].times {coin[:value] } }
aaa
3.times { aaa << [2] }
aaa = []
3.times { [2] }
3.times [2]
coins
coins.each_with_object([]) { |coin, object| coin[:quantity].times { object << coin[:value] } }
coins.each_with_object([]) { |coin, object| object << coin[:value] }
coins.each_with_object([]) { |coin, object| coin[:quantity].times {object << coin[:value] } }
2.times { 1 }
coins.flat_map { |coin| coin[:quantity].times {coin[:value] } }
coins.flat_map { |coin| coin[:quantity].times {coin[:value]) } }
coins.flat_map { |coin| coin[:quantity].times(coin[:value]) }
coins.flat_map { |coin| coin[:value] * coin[:quantity] }
coins.maP
c
find_coin_stack(coin)[:quantity] > 0
exit
find_coin_stack(coin)[:quantity] > 0
find_coin_stack(coin)[:quantity]
find_coin_stack(coin)
c
exit
c
exit
payment
clear_payment
payment
change_in_coins(change_sum)
change_sum
exit
c
cc
c
coin
c
sum
c
change_sum
coins
c
change - coin < 0 || coin_not_available?(coin)
coin
c
coin
change - coin < 0 || coin_not_available?(coin)
c
change - coin < 0 || coin_not_available?(coin)
c
change - coin < 0 || coin_not_available?(coin)
c
change - coin < 0 || coin_not_available?(coin)
change - coin < 0
coin_not_available?(coin)
coin
c
change
coin
sum
